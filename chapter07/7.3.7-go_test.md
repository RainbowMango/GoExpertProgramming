## 前言
前面的章节我们分析了每种测试的数据结构及其实现原理，本节我们看一下go test的执行机制。

Go 有多个命令行工具，go test只是其中一个。go test命令的函数入口在`src/cmd/go/internal/test/test.go:runTest()`，这个函数就是go test的大脑。

## runTest()
runTest()函数场景如下：
```go
func runTest(cmd *base.Command, args []string)
```
GO 命令行工具的实现中，都遵循这种函数声明，其中args即命令行输入的全部参数。

runTest首先会分析所有需要测试的包，为每个待测包生成一个二进制文件，然后执行。

## 两种运行模式
go test运行时，根据是否指定package分为两种模式，即本地目录模式和包列表模式。

### 本地目录模式
当执行测试并没有指定package时，即以本地目录模式运行，例如使用"go test"或者"go test -v"来启动测试。

本地目录模式下，go test编译当前目录的源码文件和测试文件，并生成一个二进制文件，最后执行并打印结果。

### 包列表模式
当执行测试并显式指定package时，即以包列表模式运行，例如使用"go test math"来启动测试。

包列表模式下，go test为每个包生成一个测试二进制文件，并分别执行它。
包列表模式是在Go 1.10版本才引入的，它会把每个包的测试结果写入到本地临时文件中作为缓存，下次执行时会直接从缓存中读取测试结果，以便节省测试时间。

## 缓存机制
当满足一定的条件，测试的缓存是自动启用的，也可以显式地关闭缓存。

### 测试结果缓存
如果一次测试中，其参数全部来自"可缓存参数"集合，那么本次测试结果将被缓存。

可缓存参数集合如下：
* -cpu
* -list
* -parallel
* -run
* -short
* -v

需要注意的是，测试参数必须全部来自这个集合，其结果才会被缓存，没有参数或包含任一此集合之外的参数，结果都不会缓存。

### 使用缓存结果
如果满足条件，测试不会真正执行，而是从缓存中取出结果并呈现，结果中会有"cached"字样，表示来自缓存。

使用缓存结果也需要满足一定的条件：
* 本次测试的二进制及测试参数与之前的一次完全一致；
* 本次测试的源文件及环境变量与之前的一次完全一致；
* 之前的一次测试结果是成功的；
* 本次测试运行模式是列表模式

下面演示一个使用缓存的例子：
```go
E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src>go test gotest
ok      gotest  3.434s

E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src>go test gotest
ok      gotest  (cached)

```
前后两次执行测试，参数没变，源文件也没变化，第二次执行时会自动从缓存中获取结果，结果中“cached”即表示结果从缓存中获取。

### 禁用缓存
测试时使用一个不在“可缓存参数”集合中的参数，就不会使用缓存，比较常用的方法是指定一个参数“-count=1”。

下面演示一个禁用缓存的例子：
```go
E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src>go test gotest
ok      gotest  3.434s

E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src>go test gotest
ok      gotest  (cached)

E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src>go test gotest -count=1
ok      gotest  3.354s

```
第三次执行使用了参数"-count=1"，所以执行时不会从缓存中获取结果。